# 이벤트 패턴 설계 보고서

## 이벤트 기반 설계의 목적
- 개요
  - 애플리케이션 초기 설계 시 빠른 개발을 위해서라면은 모놀리틱으로 구축을 시작하게 된다. 하지만 시간이 지날수록 다음의 문제점들이 생긴다.
    - 지속적으로 늘어나는 유저 트래픽 (상태 변경에 대한 작업)
    - 기능의 추가로 인한 트랜잭션 단위 및 실행 시간의 증가
  - 위와 같은 문제로 인하여 이벤트 기반 설계를 진행한다.
- 이벤트 기반 설계의 장점
  - 각 컴포넌트 간 느슨한 결합을 구현할 수 있다. 이로 인해 확장 가능성에 대해서 열려 있는 코드를 작성할 수 있다.
  - 이벤트 스트림을 통해 시스템에 가해지는 부하를 조절하여 처리할 수 있다.
  - 특정 컴포넌트에 장애가 생길 경우, 다른 컴포넌트에 문제가 전파되지 않도록 하여 시스템의 안정성을 높일 수 있다. 
- 이벤트 기반 설계의 단점
  - 모놀리틱 구성에 비해서 복잡도가 증가함으로서 구현의 난이도와 디버깅의 난이도가 높다.
  - 데이터의 일관성이 지켜지지 않는 시점이 존재하고, 이에 대한 해결책이 필요하다.

## 이벤트 기반 설계 시 트랜잭션 처리의 한계
- 기존 모놀리틱 서비스의 트랜잭션 처리
  - 작업
    - 모놀리틱 서비스에서는 하나의 요청에 대하여 연관된 모든 데이터에 DB Lock 을 걸게 된다. 소프트락의 경우에는 해당 데이터 읽기는 가능하나 수정은 불가능하고, 하드락의 경우에는 접근조차 불가능하게 한다. 이 상태에서 해당 요청에 대해 rollback 을 진행해야 한다면, 개발자는 롤백 로직을 직접 제작할 필요 없이 DB 에서 이전 상태로 복구를 시키게 된다. 이러한 
  - 장점
    - 개발자가 롤백 로직을 새로 구현할 필요가 없다.
  - 단점
    - 트랜잭션의 크기가 커질수록 확장에 불리하고 대용량 트래픽에 대해서 대응하기 어려워진다.
- 이벤트 패턴에서의 트랜잭션 처리
  - 이벤트 패턴에서는 한번의 요청에 각 트랜잭션을 따로 관리함으로서, 한번에 rollback 을 진행하기 어렵다. 또한 각 모듈은 여러 DB 와 여러 서비스로 확장이 가능해 지기 때문에, 여러개의 DB 를 동시에 rollback 할 수 없는 상태이다. 
  - 2PC 프로토콜은 이론상 여러 자원을 동시 커밋/롤백이 가능한 프로토콜이다. 하지만 이종 환경이 적용 어려움이 있고, 모든 노드가 가용해야 동작한다는 단점이 있다.
  - 이러한 이유로 한개의 수정 로직에 대해서는 이에 대응하는 롤백 로직 (보상 트랜잭션) 을 작성한다.

### 사가 패턴
사가 패턴은 분산 트랜잭션 환경에서 보상 로직으로 정합성을 맞추는 패턴이다. 사가 패턴을 구현하는 데는 2가지 방법이 존재한다.
1. 오케스트레이션 사가
  - 특징
    - 모든 이벤트 흐름을 오케스트레이터가 관리한다.
  - 장점
    - 흐름에 대한 기록을 보기 쉽다.
    - 서비스 간 직접 호출이 줄어듦으로서 응집도를 높일 수 있다.
  - 단점
    - 오케스트레이터가 단일 장애점이 될 수 있으므로 가용성 확보
    - 비즈니스 로직이 오케스트레이터로 몰리는 현상 주의
2. 코레오그래피 사가
  - 특징
    - 각 서비스가 이벤트를 발행하고 구독한다.
    - 트랜잭션 아웃박스 패턴을 사용하여 각 요청에 대해 원자성을 구현한다.
  - 장점
    - 단일 장애점이 존재하지 않는다.
  - 단점
    - 호출에 대한 기록을 보기 어렵다. -> 고도화된 로그로 디버깅/관리 필요
    - 이벤트 중복 호출 및 순서 설계를 잘 해야한다.

## 이벤트 기반 설계 시 트랜잭션 에러 대응 방안

이벤트 기반 설계 시 트랜잭션 에러는 다음 5개로 분류할 수 있다고 생각한다.
1. 비즈니스 로직에서 난 예상된 에러 (거의 모든 에러)
  - 해당 경우에는 보상 트랜잭션을 실행한다.
2. 비즈니스 로직에서 난 타임아웃 에러
  - 일정 횟수만큼 일정 시간 간격을 두고 재시도를 진행한다. 계속 에러가 난다면, DLQ 로 해당 작업을 넘긴다.
3. 이벤트 생성 실패
  - 해당 경우에는 DLQ 에 작업을 push 하고, 일정 횟수만큼 일정 시간 간격을 두고 재시도를 진행한다.
4. 보상 로직 실행 실패
  - 해당 경우에는 DLQ 큐에 작업을 push 하고, 일정 횟수만큼 일정 시간 간격을 두고 재시도를 진행한다.
5. 모든 재시도가 실패할 경우 (제일 드문 경우)
  - 개발자가 수동으로 작업을 진행할 수 있게 로깅 또는 slack 으로 alert 를 준다.

## 도메인 분리
- 주문 서비스
  - OrderService
  - OrderPaymentService
  - OrderProductService
- 상품 서비스
  - ProductService
- 잔고 서비스
  - BalanceService
- 쿠폰 서비스
  - CouponService
  - IssuedCouponService
  - IssueRequestService
- 데이터 서비스
  - DataPlatformService

## 플로우 설계
- 주문
  - 정상 플로우
    - OrderService.CreateOrder -> ProductService.decreaseStock -> BalanceService.useBalance -> CouponService.useCoupon -> OrderDataPlatformService.publish
    - OrderId 를 공통의 키로 사용
  - 보상 플로우
    - 각 서비스에서 보상 트랜잭션을 구현
      - OrderService.createOrderCompensation
      - ProductService.decreaseStock
      - BalanceService.useBalanceCompensation
      - IssuedCouponService.useCouponCompensation