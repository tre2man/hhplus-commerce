# 카프카 설계 보고서

## 적용한 Saga 패턴
- Choreography: 각 서비스가 독립적으로 동작하며, 이벤트를 통해 서로 통신한다.
- 이유 : 오케스트레이터를 두게 되면 단일 장애점이 되어 시스템에 문제가 발생할 수 있어 코레오그래피 패턴을 적용하였다.

## 카프카를 적용한 로직
1. 주문
    - 주문은 주문 생성, 결제, 재고 감소 등 여러 단계로 이루어져 있다.
    - 각 단계는 독립적인 서비스로 분리되어 있으며, 각 서비스는 카프카를 통해 통신한다.
    - 각 서비스는 자신의 작업이 완료되면 다음 단계로 메시지를 전송한다.
2. 선착순 쿠폰
    - 선착순 쿠폰은 선착순으로 발급되어야 하므로, 쿠폰 발급 로직을 카프카로 분리하여 처리량을 높인다.
    - 쿠폰 발급 로직은 쿠폰 발급 요청을 카프카에 전송하고, 카프카 컨슈머가 쿠폰 발급 로직을 처리한다.
    - 쿠폰 발급 로직은 동일한 쿠폰에 대하여 일관된 순서를 보장해야 하므로, 쿠폰 ID를 파티션 키로 사용하여 동일한 파티션에 대해서는 순서를 보장하는 카프카의 특징을 활용한다.

## 카프카 구성
- 컨슈머 구성
  - 리스너는 토픽과 리스너 그룹을 필수로 설정한다.
- 프로듀서 구성
  - 각 이벤트별 프로듀서를 생성한다. 
- 토픽 구성
  - confluent/cp-kafka:7.4.0 이미지 사용
  - 3개의 브로커로 구성된 클러스터 구축
  - Kraft 모드로 설정하여 Zookeeper 없이 운영

## 주문 로직 설계
[주문로직](./주문로직설계.jpeg)

### 각 이벤트의 key
주문 생성 완료 이벤트 : userId
잔고 차감 완료 이벤트 : userId
재고 차감 완료 이벤트 : userId (병렬 처리를 위해 productId 로 진행하고 싶었으나, 상품 리스트 재고 차감이기에 마땅한 해결 방법이 생각나지 않았습니다.)
쿠폰 사용 완료 이벤트 : userId
