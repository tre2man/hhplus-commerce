# 카프카 학습 보고서

## 카프카란?
- 메시지를 발행하는 프로듀서와 메시지를 소비하는 컨슈머 사이에서 메시지 큐 역할을 하는 브로커 중 하나이다.
- 카프카를 사용하는 이벤트 패턴
  - 프로듀서
    - 메시지 생성 책임
  - 컨슈머
    - 메시지 소비 책임
    - 메시지를 읽을때마다 파티션별 offset 정보를 업데이트하여 메시지를 읽은 위치를 관리
  - 브로커
    - 메시지를 저장하고 관리하는 책임 : Kafka
    - 클러이언트 요청 처리
    - 메타데이터 관리 (토픽, 파티션 정보 등등)

## 카프카의 특징
- 높은 처리량
- 낮은 지연시간
- 내구성 : 디스크 기반 저장
- 확장성 : 수평적 확장 기능
- 내결함성 : 복제를 통한 고가용성 구축

## 카프카의 구성 요소
- Message
  - key : key, 파티션을 분류하는 기준이 됨
  - value : 메시지 값
  - headers (옵셔널) : 메시지 메타데이터
  - timestamp : 메시지 생성 시간
  - offset : 파티션 내 위치
- 토픽
  - 메시지를 분류하는 기준 중의 하나이다. n 개의 파티션으로 구성이 되어 있다.
  - ```__consumer_offsets``` 는 각 컨슈머 그룹의 offset 을 관리하는 토픽이다.
- 파티션
  - 메시지를 처리하는 단위이다. 하나의 토픽은 여러 개의 파티션으로 구성될 수 있다.
  - **같은 파티션에 대해서는 순서를 보장한다.**
  - 주로 동시에 처리되면 안되는 자원의 경우에는 같은 파티션에서 처리, 병렬로 처리되어도 괜찮은 자원의 경우에는 다른 파티션에서 실행하여 처리 속도를 높인다.
  - 예시) 
    - 유저 1,2,3 의 포인트 차감은 동시에 일어나도 되므로 다른 파티션에서 진행되어도 된다.
    - 유저 1의 포인트 충전과 차감은 동시에 일어나면 안 되므로, 같은 파티션에서 실행되어야 함.
  - 하나의 파티션에서 여러개의 컨슈머가 메시지를 컨슘하게 되면 메시지 처리의 순서를 보장할 수 없게 된다. 컨슈머에서 메시지를 소비할 경우 컨슈머에서 파티션별 offset 정보를 업데이트 하기 때문에 offset 이 꼬일 수 있다. 즉, **하나의 파티션에는 하나의 컨슈머만 접근이 가능하다.** 반대로 하나의 컨슈머에서 여러개의 파티션에 접근하는 것은 가능하다. 다만 처리 속도가 느려질 뿐 이다.
  - **파티션 수를 줄일 수는 없다.** 파티션을 지우는 경우에는 기존 데이터가 사라지기 때문이다. 파티션 수를 줄이기 위해서는 새 토픽을 만들고, 해당 토픽으로 데이터를 이관해야 한다.
  - 컨슈머를 사용할 때는 consumer group 모드와 standalone 모드가 있다.
- 컨슈머 그룹
  - 하나의 토픽에 발행된 메시지를 여러 서비스가 컨슘하기 위해 그룹을 설정해둠.
  - 같은 토픽에 대한 컨슈머를 늘리고 싶다면 별도의 컨슈머 그룹을 만들어서 구독한다.
  - 컨슈머 개수가 파티션 개수보다 많다면 잉여 컨슈머는 메시지 소비가 불가능함 (하나의 파티션에 대해서 여러개의 컨슈머가 붙을 수 없다)
  - 여러 개의 컨슈머 그룹이 하나의 토픽에 대해서 바라보고 있을 때, 하나의 파티션을 여러개의 컨슈머가 소비할 수 있다. 이 때는 코디네이터에서 받은 offset 을 기준으로 컨슘한다. ```__consumer_offsets``` 이러한 이유로 각 컨슈머가 다른 offset 을 가지고 컨슘하기 때문에 중복 소비의 문제는 사라진다. [해당 내용](https://docs.confluent.io/platform/current/clients/consumer.html)
  - 리밸런싱
    - 컨슈머 그룹 내 컨슈머 간에 파티션 소유권을 재할당하여 offset 조정을 하여 메시지가 정상적으로 컨슘될 수 있게 함.
    - 리밸런싱이 일어나는 원인은 다음과 같다.
      - 컨슈머 그룹 내 컨슈머가 생성/삭제 된 경우
      - ```max.poll.interval.ms``` 시간 내 poll() 요청 못보낸 경우
      - ```session.timeout.ms``` 시간 내 하트비트를 못보낸 경우
    - 리밸런싱 중에는 컨슈머가 메시지를 읽을 수 없다. -> 되도록 하지 말자...
- 클러스터
  - 고가용성, 메시지 처리량 증가를 위해서 사용
  - 파티션별 리더가 지정된다.
    - 리더 레플리카
      - 각 파티션은 1개의 리더 레플리카를 가진다. 모든 프로듀서 컨슈머 요청은 리더를 통해서 진행한다.
    - 팔로워 레플리카
      - 리더를 제외한 나머지 레플리카가 팔로워가 된다. 리더가 중단되는 경우 팔로워 중 하나를 리더로 선출한다.
      - 주기적으로 데이터를 리더로부터 가져온다. 리더 메시지가 동기화되지 않는 레플리카는 리더로 선출될 수 없다.
  - 코디네이터
    - 최신 kafka 는 ZooKeeper 의존성 없이 실행 가능하다
    - 브로커 중 하나가 코디네이터로 지정됨.
    - 커밋된 오프셋을 관리하여 분산 환경이 안정적으로 동작할 수 있게 한다.

## 참고자료
[카프카 컨슈머 동작](https://devocean.sk.com/community/detail.do?ID=165478&boardType=DEVOCEAN_STUDY&page=1)
[컨슈머 토픽](https://docs.confluent.io/platform/current/clients/consumer.html)
